import * as path from 'path';

/**
 * Функция обработки 3д-объекта
 */
export type objectCallback = (obj: Object3 | Model3D) => boolean;

/**
 * Модуль общих функций
 */
export module common{

    /**
     * Перебор всех объектов в обратном направлении и выполнение функции с ними
     * (позволяет избежать ошибок при удалении объекта)
     * @param obj Исходный объект
     * @param cb Выполняемая функция (если возвращает false, и параметр 
     * callObjFirst равен true то перебор по вложенным 
     * объектам производиться не будет)
     * @param callObjFirst Выполнять функцию сначала с исходным объектом, 
     * а потом с вложенными 
     */
    export function forEachObjectReverse(obj: Object3 | Model3D, cb: objectCallback, 
        callObjFirst?: boolean){
        if (callObjFirst){
            if (!cb(obj))
                return;
        }
        if (obj.List){
            let list = obj.AsList();
            for (let i = list.Count - 1; i >= 0; i--){
                forEachObjectReverse(list.Objects[i], cb, callObjFirst);
            }
        }
        if (!callObjFirst){
            cb(obj)
        }
    }

    /**
     * Перебор всех объектов и выполнение функции с ними
     * @param obj Исходный объект
     * @param cb Выполняемая функция (если возвращает false, и параметр 
     * callObjFirst равен true то перебор по вложенным 
     * объектам производиться не будет)
     * @param callObjFirst Выполнять функцию сначала с исходным объектом, 
     * а потом с вложенными 
     */
    export function forEachObject(obj: Object3 | Model3D, cb: objectCallback, 
        callObjFirst?: boolean){
        if (callObjFirst){
            if (!cb(obj))
                return;
        }
        if (obj.List){
            let list = obj.AsList();
            for (let i = 0; i < list.Count; i++){
                forEachObjectReverse(list.Objects[i], cb, callObjFirst);
            }
        }
        if (!callObjFirst){
            cb(obj)
        }
    }
}

/**
 * Модуль сохранения
 */
export module saving {    
    /**
     * Сохранить объект в файл
     * @param obj Сохраняемый объект
     * @param filename Имя файла
     */
    export function SaveObject(obj: Object3, filename: string){
        SaveObjects([obj], filename);
    }    
    
    export function SaveObjects(objs: Object3[], filename: string){
        Undo.BeginOper(''); //создаем отменяемый блок операций
        try{
            common.forEachObjectReverse(Model, (objec: Object3)=>{            
                if (!objec || objec === Model)
                    return true;
                for (let i = 0; i < objs.length; i++){
                    let obj = objs[i];
                    if (objec !== obj && !objec.IsOwner(obj)){
                        DeleteObject(objec);
                        return false;
                    }
                }
                return true;
            }, true);
            Action.SaveModel(filename); //сохраняем то, что получилось
        }
        finally{
            Undo.EndAndUndoOper(); //завершаем блок операций и отменяем его (возвращаемся к начальному состоянию)
        }
    }
    
    export function SaveObjectByName(objectName: string, filename: string, firstOnly: boolean){
    
        function getFilename(filename: string, num: number): string{        
            let parsedPath = path.parse(filename);
            return parsedPath.root + parsedPath.dir + parsedPath.name + num + parsedPath.ext;
        }
    
        let found = false;
        let num = 1;
        Model.forEach((obj)=>{
            if (!found && (obj.Name === objectName)){
                SaveObjects([obj], firstOnly? filename: getFilename(filename, num));
                if (firstOnly){
                    found = true;
                }
            }
        })    
    }
}