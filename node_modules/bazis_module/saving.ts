import * as path from 'path';
/**
 * 
 */
type objectCallback = (obj: Object3) => boolean;
/**
 * Перебор всех объектов в обратном направлении и выполнение функции с ними
 * (позволяет избежать ошибок при удалении объекта)
 * @param obj Исходный объект
 * @param cb Выполняемая функция (если возвращает false, и параметр 
 * callObjFirst равен true то перебор по вложенным 
 * объектам производиться не будет)
 * @param callObjFirst Выполнять функцию сначала с исходным объектом, 
 * а потом с вложенными 
 */
function forEachObjectReverse(obj: Object3, cb: objectCallback, callObjFirst?: boolean){
    if (callObjFirst){
        if (!cb(obj))
            return;
    }
    if (obj.List){
        let list = obj.AsList();
        for (let i = list.Count - 1; i >= 0; i--){
            forEachObjectReverse(list.Objects[i], cb, callObjFirst);
        }
    }
    if (!callObjFirst){
        cb(obj)
    }
}

export function SaveObjects(objs: Object3[], filename: string){
    Undo.BeginOper(''); //создаем отменяемый блок операций
    try{
        forEachObjectReverse(Model, (objec: Object3)=>{            
            if (!objec || objec === Model)
                return;
            for (let i = 0; i < objs.length; i++){
                let obj = objs[i];
                if (objec !== obj && !objec.IsOwner(obj)){
                    DeleteObject(objec);
                    return false;
                }
            }
            return true;
        }, true);
        Action.SaveModel(filename); //сохраняем то, что получилось
    }
    finally{
        Undo.EndAndUndoOper(); //завершаем блок операций и отменяем его (возвращаемся к начальному состоянию)
    }
}

export function SaveObjectByName(objectName: string, filename: string, firstOnly: boolean){

    function getFilename(filename: string, num: number): string{        
        let parsedPath = path.parse(filename);
        return parsedPath.root + parsedPath.dir + parsedPath.name + num + parsedPath.ext;
    }

    let found = false;
    let num = 1;
    Model.forEach((obj)=>{
        if (!found && (obj.Name === objectName)){
            SaveObjects([obj], firstOnly? filename: getFilename(filename, num));
            if (firstOnly){
                found = true;
            }
        }
    })    
}